<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Educational Games Research</title>
    <base href="https://cdn.jsdelivr.net/gh/Game-Idiots/game-cdn/Polytrack/">
    <link rel="preload" href="forced_square.woff2" as="font" type="font/woff2" crossorigin="anonymous" />
    <link rel="preload" href="images/logo.svg" as="image" type="image/svg+xml" />
    <link rel="preload" href="images/discord.svg" as="image" type="image/svg+xml" />
    <link rel="manifest" href="manifest.json" />
    <meta name="viewport"
        content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,viewport-fit=cover,user-scalable=no">
    <!-- Worker wrapper: for cross-origin worker URLs, sync-fetch script and create a same-origin blob worker -->
    <script>
        (function () {
            const NativeWorker = window.Worker;
            if (!NativeWorker) return;

            // If a remote host does not provide CORS, route matching requests through a public CORS proxy.
            // NOTE: public proxies have limits and privacy implications; for production, enable CORS on the server or host assets on your origin.
            const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
            const CORS_BLOCKED_HOST = 'vps.kodub.com';
            function rewriteUrlForCors(url) {
                try {
                    const u = new URL(url, document.baseURI);
                    if (u.hostname === CORS_BLOCKED_HOST) {
                        return CORS_PROXY + encodeURIComponent(u.href);
                    }
                } catch (e) {
                    // ignore
                }
                return url;
            }

            window.Worker = function (scriptURL, options) {
                try {
                    // resolve relative URLs against document base
                    const resolved = new URL(scriptURL, document.baseURI).href;
                    if (new URL(resolved).origin !== location.origin) {
                        // attempt synchronous fetch of the worker script
                        const xhr = new XMLHttpRequest();
                        const fetchUrl = rewriteUrlForCors(resolved);
                        xhr.open('GET', fetchUrl, false); // synchronous
                        xhr.send(null);
                        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) {
                            // rewrite importScripts(...) string arguments to absolute URLs so they work from blob workers
                            let scriptText = xhr.responseText;
                            try {
                                scriptText = scriptText.replace(/importScripts\s*\(\s*([^\)]+)\)/g, function (_, args) {
                                    // replace each quoted URL within the arguments with an absolute URL resolved against 'resolved'
                                    const rewrittenArgs = args.replace(/(['"`])([^'"`]+)\1/g, function (m, quote, url) {
                                        try {
                                            const abs = new URL(url, resolved).href;
                                            // if the importScripts target is on the blocked host, route it via the CORS proxy
                                            const proxied = (new URL(abs).hostname === CORS_BLOCKED_HOST) ? (CORS_PROXY + encodeURIComponent(abs)) : abs;
                                            return quote + proxied + quote;
                                        } catch (e) {
                                            // if resolution fails, return original
                                            return m;
                                        }
                                    });
                                    return 'importScripts(' + rewrittenArgs + ')';
                                });
                            } catch (e) {
                                console.warn('Worker wrapper: importScripts rewrite failed, continuing with original script.', e);
                            }

                            // Inject a small runtime at the top of the worker script that:
                            //  - provides resolve(url) to make relative URLs absolute against the original worker URL
                            //  - applies the same CORS proxy for known blocked hosts
                            //  - overrides fetch and WebAssembly.instantiateStreaming to resolve string/Request targets automatically
                            try {
                                const workerBase = JSON.stringify(resolved);
                                const corsProxy = JSON.stringify(CORS_PROXY);
                                const corsBlocked = JSON.stringify(CORS_BLOCKED_HOST);
                                const injected = `
                                    (function(){
                                        const __WORKER_BASE = ${workerBase};
                                        const __CORS_PROXY = ${corsProxy};
                                        const __CORS_BLOCKED = ${corsBlocked};
                                        function __resolve(u){
                                            try{
                                                const abs = new URL(u, __WORKER_BASE).href;
                                                if (new URL(abs).hostname === __CORS_BLOCKED) return __CORS_PROXY + encodeURIComponent(abs);
                                                return abs;
                                            }catch(e){
                                                return u;
                                            }
                                        }
                                        // wrap fetch to resolve string/Request urls
                                        const __nativeFetch = self.fetch;
                                        self.fetch = function(input, ...args){
                                            try{
                                                if (typeof input === 'string') input = __resolve(input);
                                                else if (input && input.url) input = new Request(__resolve(input.url), { method: input.method, headers: input.headers, body: input.body, mode: input.mode, credentials: input.credentials, cache: input.cache, redirect: input.redirect, referrer: input.referrer, integrity: input.integrity });
                                            }catch(e){}
                                            return __nativeFetch.call(this, input, ...args);
                                        };
                                        // wrap instantiateStreaming to resolve string argument
                                        if (typeof WebAssembly !== 'undefined' && WebAssembly.instantiateStreaming){
                                            const __nativeInst = WebAssembly.instantiateStreaming;
                                            WebAssembly.instantiateStreaming = function(resp, importObj){
                                                if (typeof resp === 'string') resp = self.fetch(__resolve(resp));
                                                return __nativeInst.call(WebAssembly, resp, importObj);
                                            };
                                        }
                                    })();
                                `;
                                scriptText = injected + '\n' + scriptText;
                            } catch (e) {
                                console.warn('Worker wrapper: failed to inject resolver/shims', e);
                            }

                            const blob = new Blob([scriptText], { type: 'application/javascript' });
                            const blobUrl = URL.createObjectURL(blob);
                            return new NativeWorker(blobUrl, options);
                        } else {
                            console.warn('Worker wrapper: sync XHR failed with status', xhr.status, 'falling back to native Worker.');
                        }
                    }
                } catch (e) {
                    // if anything goes wrong, fall back to native Worker
                    console.warn('Worker wrapper error, falling back to native Worker:', e);
                }
                return new NativeWorker(scriptURL, options);
            };
        }());
    </script>
    <script defer="defer" src="error_screen.bundle.js"></script>
    <script defer="defer" src="main.bundle.js"></script>
</head>

<body><canvas id="screen"></canvas>
    <div id="ui"></div>
    <div id="transition-layer"></div>
</body>

</html>